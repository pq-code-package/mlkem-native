#!/usr/bin/env python3
# Copyright (c) The mlkem-native project authors
# SPDX-License-Identifier: Apache-2.0 OR ISC OR MIT

import sys
import re
import argparse


def add_cfi_directives(text, arch):
    lines = text.split("\n")
    result = []
    i = 0

    while i < len(lines):
        line = lines[i].rstrip()

        if arch == "aarch64":
            # Check for SIMD save pattern: stp d8,d9; stp d10,d11; stp d12,d13; stp d14,d15
            if i + 3 < len(lines):
                pattern_text = "\n".join(lines[i : i + 4])
                simd_save_pattern = (
                    r"(\s*)stp\s+d8,\s*d9,\s*\[sp(?:,\s*#([^]]+))?\]\s*\n"
                    r"\s*stp\s+d10,\s*d11,\s*\[sp(?:,\s*#([^]]+))?\]\s*\n"
                    r"\s*stp\s+d12,\s*d13,\s*\[sp(?:,\s*#([^]]+))?\]\s*\n"
                    r"\s*stp\s+d14,\s*d15,\s*\[sp(?:,\s*#([^]]+))?\]"
                )
                match = re.match(simd_save_pattern, pattern_text, re.IGNORECASE)
                if match:
                    indent = match.group(1)
                    offsets = [match.group(j + 2) or "0" for j in range(4)]
                    for j, reg_pair in enumerate(
                        [(8, 9), (10, 11), (12, 13), (14, 15)]
                    ):
                        result.append(lines[i + j].rstrip())
                        try:
                            offset_val = int(offsets[j], 0)
                            result.append(
                                f"{indent}.cfi_rel_offset d{reg_pair[0]}, 0x{offset_val:x}"
                            )
                            result.append(
                                f"{indent}.cfi_rel_offset d{reg_pair[1]}, 0x{offset_val+8:x}"
                            )
                        except:
                            result.append(
                                f"{indent}.cfi_rel_offset d{reg_pair[0]}, {offsets[j]}"
                            )
                            result.append(
                                f"{indent}.cfi_rel_offset d{reg_pair[1]}, ({offsets[j]}+8)"
                            )
                    i += 4
                    continue

            # Check for SIMD restore pattern: ldp d8,d9; ldp d10,d11; ldp d12,d13; ldp d14,d15
            if i + 3 < len(lines):
                pattern_text = "\n".join(lines[i : i + 4])
                simd_restore_pattern = (
                    r"(\s*)ldp\s+d8,\s*d9,\s*\[sp(?:,\s*#[^]]+)?\]\s*\n"
                    r"\s*ldp\s+d10,\s*d11,\s*\[sp(?:,\s*#[^]]+)?\]\s*\n"
                    r"\s*ldp\s+d12,\s*d13,\s*\[sp(?:,\s*#[^]]+)?\]\s*\n"
                    r"\s*ldp\s+d14,\s*d15,\s*\[sp(?:,\s*#[^]]+)?\]"
                )
                match = re.match(simd_restore_pattern, pattern_text, re.IGNORECASE)
                if match:
                    indent = match.group(1)
                    for j, reg_pair in enumerate(
                        [(8, 9), (10, 11), (12, 13), (14, 15)]
                    ):
                        result.append(lines[i + j].rstrip())
                        result.append(f"{indent}.cfi_restore d{reg_pair[0]}")
                        result.append(f"{indent}.cfi_restore d{reg_pair[1]}")
                    i += 4
                    continue

            # Check for GPR save pattern: stp x19,x20 through stp x29,x30
            if i + 5 < len(lines):
                pattern_text = "\n".join(lines[i : i + 6])
                gpr_save_pattern = (
                    r"(\s*)stp\s+x19,\s*x20,\s*\[sp(?:,\s*#([^]]+))?\]\s*\n"
                    r"\s*stp\s+x21,\s*x22,\s*\[sp(?:,\s*#([^]]+))?\]\s*\n"
                    r"\s*stp\s+x23,\s*x24,\s*\[sp(?:,\s*#([^]]+))?\]\s*\n"
                    r"\s*stp\s+x25,\s*x26,\s*\[sp(?:,\s*#([^]]+))?\]\s*\n"
                    r"\s*stp\s+x27,\s*x28,\s*\[sp(?:,\s*#([^]]+))?\]\s*\n"
                    r"\s*stp\s+x29,\s*x30,\s*\[sp(?:,\s*#([^]]+))?\]"
                )
                match = re.match(gpr_save_pattern, pattern_text, re.IGNORECASE)
                if match:
                    indent = match.group(1)
                    offsets = [match.group(j + 2) or "0" for j in range(6)]
                    for j, reg_pair in enumerate(
                        [(19, 20), (21, 22), (23, 24), (25, 26), (27, 28), (29, 30)]
                    ):
                        result.append(lines[i + j].rstrip())
                        try:
                            offset_val = int(offsets[j], 0)
                            result.append(
                                f"{indent}.cfi_rel_offset x{reg_pair[0]}, 0x{offset_val:x}"
                            )
                            result.append(
                                f"{indent}.cfi_rel_offset x{reg_pair[1]}, 0x{offset_val+8:x}"
                            )
                        except:
                            result.append(
                                f"{indent}.cfi_rel_offset x{reg_pair[0]}, {offsets[j]}"
                            )
                            result.append(
                                f"{indent}.cfi_rel_offset x{reg_pair[1]}, ({offsets[j]}+8)"
                            )
                    i += 6
                    continue

            # Check for GPR restore pattern: ldp x19,x20 through ldp x29,x30
            if i + 5 < len(lines):
                pattern_text = "\n".join(lines[i : i + 6])
                gpr_restore_pattern = (
                    r"(\s*)ldp\s+x19,\s*x20,\s*\[sp(?:,\s*#[^]]+)?\]\s*\n"
                    r"\s*ldp\s+x21,\s*x22,\s*\[sp(?:,\s*#[^]]+)?\]\s*\n"
                    r"\s*ldp\s+x23,\s*x24,\s*\[sp(?:,\s*#[^]]+)?\]\s*\n"
                    r"\s*ldp\s+x25,\s*x26,\s*\[sp(?:,\s*#[^]]+)?\]\s*\n"
                    r"\s*ldp\s+x27,\s*x28,\s*\[sp(?:,\s*#[^]]+)?\]\s*\n"
                    r"\s*ldp\s+x29,\s*x30,\s*\[sp(?:,\s*#[^]]+)?\]"
                )
                match = re.match(gpr_restore_pattern, pattern_text, re.IGNORECASE)
                if match:
                    indent = match.group(1)
                    for j, reg_pair in enumerate(
                        [(19, 20), (21, 22), (23, 24), (25, 26), (27, 28), (29, 30)]
                    ):
                        result.append(lines[i + j].rstrip())
                        result.append(f"{indent}.cfi_restore x{reg_pair[0]}")
                        result.append(f"{indent}.cfi_restore x{reg_pair[1]}")
                    i += 6
                    continue

            # Rule 7: add sp, sp, #offset -> .cfi_adjust_cfa_offset (-(offset))
            match = re.match(
                r"(\s*)add\s+sp,\s*sp,\s*#(0x[0-9a-fA-F]+|\d+)", line, re.IGNORECASE
            )
            if match:
                indent, offset_str = match.groups()
                offset = (
                    int(offset_str, 16)
                    if offset_str.lower().startswith("0x")
                    else int(offset_str)
                )
                result.append(line)
                result.append(f"{indent}.cfi_adjust_cfa_offset -{offset:#x}")
                i += 1
                continue

            # Rule 8: sub sp, sp, #offset -> .cfi_adjust_cfa_offset (offset)
            match = re.match(
                r"(\s*)sub\s+sp,\s*sp,\s*#(0x[0-9a-fA-F]+|\d+)", line, re.IGNORECASE
            )
            if match:
                indent, offset_str = match.groups()
                offset = (
                    int(offset_str, 16)
                    if offset_str.lower().startswith("0x")
                    else int(offset_str)
                )
                result.append(line)
                result.append(f"{indent}.cfi_adjust_cfa_offset {offset:#x}")
                i += 1
                continue

            # Rule 2: ret -> .cfi_endproc after ret
            match = re.match(r"(\s*)ret\s*$", line, re.IGNORECASE)
            if match:
                indent = match.group(1)
                result.append(line)
                result.append(f"{indent}.cfi_endproc")
                i += 1
                continue

        elif arch == "x86_64":
            # Check for labels and see if there's a corresponding callq
            label_match = re.match(r"^([a-zA-Z_][a-zA-Z0-9_]*):$", line)
            if label_match:
                label = label_match.group(1)
                # Check if this label is called anywhere in the text
                if re.search(rf"\s*callq\s+{re.escape(label)}\b", text, re.IGNORECASE):
                    result.append(line)
                    result.append("        .cfi_startproc")
                    i += 1
                    continue

            # x86_64: subq $OFFSET, %rsp -> .cfi_adjust_cfa_offset OFFSET (stack alloc)
            match = re.match(
                r"(\s*)subq\s+\$(0x[0-9a-fA-F]+|\d+),\s*%rsp", line, re.IGNORECASE
            )
            if match:
                indent, offset_str = match.groups()
                offset = (
                    int(offset_str, 16)
                    if offset_str.lower().startswith("0x")
                    else int(offset_str)
                )
                result.append(line)
                result.append(f"{indent}.cfi_adjust_cfa_offset {offset:#x}")
                i += 1
                continue

            # x86_64: addq $OFFSET, %rsp -> .cfi_adjust_cfa_offset -OFFSET (stack free)
            match = re.match(
                r"(\s*)addq\s+\$(0x[0-9a-fA-F]+|\d+),\s*%rsp", line, re.IGNORECASE
            )
            if match:
                indent, offset_str = match.groups()
                offset = (
                    int(offset_str, 16)
                    if offset_str.lower().startswith("0x")
                    else int(offset_str)
                )
                result.append(line)
                result.append(f"{indent}.cfi_adjust_cfa_offset -{offset:#x}")
                i += 1
                continue

            # x86_64: ret/retq -> .cfi_endproc after ret
            match = re.match(r"(\s*)retq?\s*$", line, re.IGNORECASE)
            if match:
                indent = match.group(1)
                result.append(line)
                result.append(f"{indent}.cfi_endproc")
                i += 1
                continue

        elif arch == "armv81m":
            # Armv8.1-M callee-saved registers
            armv81m_callee_saved_gprs = {
                "r4",
                "r5",
                "r6",
                "r7",
                "r8",
                "r9",
                "r10",
                "r11",
                "lr",
            }
            armv81m_callee_saved_dregs = {
                "d8",
                "d9",
                "d10",
                "d11",
                "d12",
                "d13",
                "d14",
                "d15",
            }
            # Register aliases: numeric form -> canonical name
            gpr_aliases = {"r14": "lr", "r15": "pc", "r13": "sp"}

            def parse_reg(s):
                """Parse a single register, returning (prefix, number) or None."""
                s = s.strip().lower()
                # Named aliases
                if s in ("lr", "pc", "sp"):
                    return s
                m = re.match(r"([a-z]+)(\d+)$", s)
                if not m:
                    raise ValueError(f"Cannot parse register: {s}")
                return gpr_aliases.get(s, s)

            def expand_reg_range(token):
                """Expand 'r4-r11' or 'd8-d15' into a list. Single regs returned as-is."""
                m = re.match(r"^\s*([a-z]+)(\d+)\s*-\s*([a-z]+)(\d+)\s*$", token)
                if m:
                    prefix1, lo, prefix2, hi = (
                        m.group(1),
                        int(m.group(2)),
                        m.group(3),
                        int(m.group(4)),
                    )
                    if prefix1 != prefix2:
                        raise ValueError(
                            f"Mismatched register prefixes in range: {token}"
                        )
                    return [
                        gpr_aliases.get(f"{prefix1}{n}", f"{prefix1}{n}")
                        for n in range(lo, hi + 1)
                    ]
                return [parse_reg(token)]

            def parse_reglist(reglist_str):
                """Parse a register list string, expanding ranges and normalizing aliases."""
                result = []
                for token in reglist_str.split(","):
                    result.extend(expand_reg_range(token))
                return result

            # push.w {reglist} / push {reglist}
            match = re.match(r"(\s*)push(?:\.w)?\s*\{([^}]+)\}", line, re.IGNORECASE)
            if match:
                indent = match.group(1)
                regs = parse_reglist(match.group(2))
                total_size = 4 * len(regs)
                result.append(line)
                result.append(f"{indent}.cfi_adjust_cfa_offset {total_size:#x}")
                for idx, reg in enumerate(regs):
                    if reg in armv81m_callee_saved_gprs:
                        offset = 4 * idx
                        result.append(f"{indent}.cfi_rel_offset {reg}, {offset:#x}")
                i += 1
                continue

            # vpush {d-regs}
            match = re.match(r"(\s*)vpush\s*\{([^}]+)\}", line, re.IGNORECASE)
            if match:
                indent = match.group(1)
                regs = parse_reglist(match.group(2))
                total_size = 8 * len(regs)
                result.append(line)
                result.append(f"{indent}.cfi_adjust_cfa_offset {total_size:#x}")
                for idx, reg in enumerate(regs):
                    if reg in armv81m_callee_saved_dregs:
                        offset = 8 * idx
                        result.append(f"{indent}.cfi_rel_offset {reg}, {offset:#x}")
                i += 1
                continue

            # vpop {d-regs}
            match = re.match(r"(\s*)vpop\s*\{([^}]+)\}", line, re.IGNORECASE)
            if match:
                indent = match.group(1)
                regs = parse_reglist(match.group(2))
                total_size = 8 * len(regs)
                result.append(line)
                for reg in regs:
                    if reg in armv81m_callee_saved_dregs:
                        result.append(f"{indent}.cfi_restore {reg}")
                result.append(f"{indent}.cfi_adjust_cfa_offset -{total_size:#x}")
                i += 1
                continue

            # pop.w {reglist} / pop {reglist}
            match = re.match(r"(\s*)pop(?:\.w)?\s*\{([^}]+)\}", line, re.IGNORECASE)
            if match:
                indent = match.group(1)
                regs = parse_reglist(match.group(2))
                total_size = 4 * len(regs)
                has_pc = "pc" in regs
                result.append(line)
                for reg in regs:
                    if reg in armv81m_callee_saved_gprs:
                        result.append(f"{indent}.cfi_restore {reg}")
                    elif reg == "pc":
                        # pop into pc restores lr
                        result.append(f"{indent}.cfi_restore lr")
                result.append(f"{indent}.cfi_adjust_cfa_offset -{total_size:#x}")
                if has_pc:
                    result.append(f"{indent}.cfi_endproc")
                i += 1
                continue

            # sub.w sp, #imm / sub sp, #imm / sub sp, sp, #imm
            match = re.match(
                r"(\s*)sub(?:\.w)?\s+sp,\s*(?:sp,\s*)?#(0x[0-9a-fA-F]+|\d+)",
                line,
                re.IGNORECASE,
            )
            if match:
                indent, offset_str = match.groups()
                offset = (
                    int(offset_str, 16)
                    if offset_str.lower().startswith("0x")
                    else int(offset_str)
                )
                result.append(line)
                result.append(f"{indent}.cfi_adjust_cfa_offset {offset:#x}")
                i += 1
                continue

            # add.w sp, #imm / add sp, #imm / add sp, sp, #imm
            match = re.match(
                r"(\s*)add(?:\.w)?\s+sp,\s*(?:sp,\s*)?#(0x[0-9a-fA-F]+|\d+)",
                line,
                re.IGNORECASE,
            )
            if match:
                indent, offset_str = match.groups()
                offset = (
                    int(offset_str, 16)
                    if offset_str.lower().startswith("0x")
                    else int(offset_str)
                )
                result.append(line)
                result.append(f"{indent}.cfi_adjust_cfa_offset -{offset:#x}")
                i += 1
                continue

            # bx lr â€” function return
            match = re.match(r"(\s*)bx\s+lr\s*$", line, re.IGNORECASE)
            if match:
                indent = match.group(1)
                result.append(line)
                result.append(f"{indent}.cfi_endproc")
                i += 1
                continue

        result.append(line)
        i += 1

    return "\n".join(result)


def main():

    parser = argparse.ArgumentParser(
        description="Add CFI directives to AArch64 assembly"
    )
    parser.add_argument("-i", "--input", help="Input file (default: stdin)")
    parser.add_argument("-o", "--output", help="Output file (default: stdout)")
    parser.add_argument(
        "--emit-cfi-proc-start",
        action="store_true",
        help="Emit .cfi_proc_start as first line",
    )
    parser.add_argument(
        "--arch",
        choices=["aarch64", "x86_64", "armv81m"],
        default="aarch64",
        help="Target architecture (default: aarch64)",
    )
    args = parser.parse_args()

    input_file = open(args.input, "r") if args.input else sys.stdin
    output_file = open(args.output, "w") if args.output else sys.stdout

    try:
        # Read all input
        text = input_file.read()

        # Add initial .cfi_startproc if requested
        if args.emit_cfi_proc_start:
            text = "        .cfi_startproc\n" + text

        # Process the text
        result = add_cfi_directives(text, args.arch)

        # Write output
        output_file.write(result)
    finally:
        if args.input:
            input_file.close()
        if args.output:
            output_file.close()


if __name__ == "__main__":
    main()
