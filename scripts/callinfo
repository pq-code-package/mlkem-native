#!/usr/bin/env python3
"""Parse cflow output and generate YAML with function call graph information."""

import glob
import re
import subprocess
import sys
import yaml

def parse_cflow_line(line):
    """Parse a cflow output line to extract function info."""
    # Match: "    function_name() <signature at file:line>"
    match = re.match(r'^(\s*)([^<\s]+)\s*(?:<([^>]+)>)?', line)
    if not match:
        return None

    indent, name, full_sig = match.groups()

    # Extract location from signature if present
    signature = ''
    file_path = ''
    line_num = ''
    if full_sig:
        # Look for " at file:line" pattern
        at_match = re.search(r'^(.*?)\s+at\s+([^:]+):(\d+)$', full_sig)
        if at_match:
            signature = at_match.group(1).strip()
            file_path = at_match.group(2)
            line_num = int(at_match.group(3))
        else:
            signature = full_sig.strip()

    return {
        'indent': len(indent),
        'name': name.rstrip('():'),
        'signature': signature,
        'file': file_path,
        'line': line_num
    }

def build_call_graph(source_files):
    """Build forward and reverse call graphs from cflow."""
    # Get forward call graph
    result = subprocess.run(
        ['cflow'] + source_files,
        capture_output=True, text=True, check=True
    )

    functions = {}
    stack = []

    for line in result.stdout.splitlines():
        info = parse_cflow_line(line)
        if not info:
            continue

        name = info['name']
        indent = info['indent']

        # Initialize function entry
        if name not in functions:
            functions[name] = {
                'name': name,
                'signature': info['signature'],
                'location': {
                    'file': info['file'],
                    'line': info['line']
                },
                'calls': [],
                'called_by': []
            }

        # Update signature and location if we have better info
        if info['signature'] and not functions[name]['signature']:
            functions[name]['signature'] = info['signature']
        if info['file'] and not functions[name]['location']['file']:
            functions[name]['location']['file'] = info['file']
        if info['line'] and not functions[name]['location']['line']:
            functions[name]['location']['line'] = info['line']

        # Maintain stack based on indentation
        while stack and stack[-1][1] >= indent:
            stack.pop()

        # If we have a caller, record the relationship
        if stack:
            caller = stack[-1][0]
            if name not in functions[caller]['calls']:
                functions[caller]['calls'].append(name)
            if caller not in functions[name]['called_by']:
                functions[name]['called_by'].append(caller)

        stack.append((name, indent))

    return functions

def main():
    # Find all C files in mlkem/src
    source_files = sorted(glob.glob('mlkem/src/**/*.c', recursive=True))

    if not source_files:
        print("Error: No C files found in mlkem/src/", file=sys.stderr)
        sys.exit(1)

    functions = build_call_graph(source_files)

    # Sort calls and called_by lists for each function
    for func in functions.values():
        func['calls'].sort()
        func['called_by'].sort()
        # Remove linebreaks from signature
        if func['signature']:
            func['signature'] = ' '.join(func['signature'].split())

    # Convert to list and sort by name
    output = {
        'functions': sorted(functions.values(), key=lambda f: f['name'])
    }

    print(yaml.dump(output, default_flow_style=False, sort_keys=False, width=float('inf')))

if __name__ == '__main__':
    main()
