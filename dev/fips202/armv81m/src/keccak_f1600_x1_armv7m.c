/*
 * Copyright (c) The mlkem-native project authors
 * SPDX-License-Identifier: Apache-2.0 OR ISC OR MIT
 */

#include "../../../../common.h"
#include "../../../../verify.h"

#if defined(MLK_FIPS202_ARMV81M_NEED_X1) && \
    !defined(MLK_CONFIG_MULTILEVEL_NO_SHARED)

#include <stdint.h>
#include "fips202_native_armv81m.h"

/*
 * TEMPORARY: Bit-interleaving using efficient shift-and-mask operations.
 * TODO: Replace with optimized assembly implementations
 * (as a part of XORBytes and ExtractBytes)
 */

/* Extract even-indexed bits from 64-bit value into lower 32 bits */
static uint32_t bitinterleave_even(uint64_t x)
{
  uint64_t t;
  t = x & 0x5555555555555555ULL;
  t = (t | (t >> 1)) & 0x3333333333333333ULL;
  t = (t | (t >> 2)) & 0x0f0f0f0f0f0f0f0fULL;
  t = (t | (t >> 4)) & 0x00ff00ff00ff00ffULL;
  t = (t | (t >> 8)) & 0x0000ffff0000ffffULL;
  t = (t | (t >> 16)) & 0x00000000ffffffffULL;
  return (uint32_t)t;
}

/* Extract odd-indexed bits from 64-bit value into lower 32 bits */
static uint32_t bitinterleave_odd(uint64_t x)
{
  return bitinterleave_even(x >> 1);
}

/* Spread 32-bit value across even bit positions of 64-bit result */
static uint64_t spread_even(uint32_t x)
{
  uint64_t t = x;
  t = (t | (t << 16)) & 0x0000ffff0000ffffULL;
  t = (t | (t << 8)) & 0x00ff00ff00ff00ffULL;
  t = (t | (t << 4)) & 0x0f0f0f0f0f0f0f0fULL;
  t = (t | (t << 2)) & 0x3333333333333333ULL;
  t = (t | (t << 1)) & 0x5555555555555555ULL;
  return t;
}

/* Combine even and odd 32-bit halves into interleaved 64-bit value */
static uint64_t bitdeinterleave(uint32_t even, uint32_t odd)
{
  return spread_even(even) | (spread_even(odd) << 1);
}

/*
 * Convert normal state to bit-interleaved format.
 * Input:  state[25] as 64-bit lanes
 * Output: state_bi[50] as 32-bit words (pairs of even/odd bits per lane)
 */
static void interleave_state(uint32_t *state_bi, const uint64_t *state)
{
  for (size_t i = 0; i < 25; i++)
  {
    state_bi[i * 2 + 0] = bitinterleave_even(state[i]);
    state_bi[i * 2 + 1] = bitinterleave_odd(state[i]);
  }
}

/*
 * Convert bit-interleaved state back to normal format.
 * Input:  state_bi[50] as 32-bit words (pairs of even/odd bits per lane)
 * Output: state[25] as 64-bit lanes
 */
static void deinterleave_state(uint64_t *state, const uint32_t *state_bi)
{
  for (size_t i = 0; i < 25; i++)
  {
    state[i] = bitdeinterleave(state_bi[i * 2 + 0], state_bi[i * 2 + 1]);
  }
}

#define mlk_keccak_f1600_x1_native_impl \
  MLK_NAMESPACE(keccak_f1600_x1_native_impl)
int mlk_keccak_f1600_x1_native_impl(uint64_t *state)
{
  /*
   * TEMPORARY: Bit-interleaving using efficient shift-and-mask operations.
   * TODO: Replace with optimized assembly implementations
   * (as a part of XORBytes and ExtractBytes)
   */
  MLK_ALIGN uint32_t state_bi[50];

  /* Interleave the state into bit-interleaved format */
  interleave_state(state_bi, state);

  /* Run the permutation */
  mlk_keccak_f1600_x1_armv7m_asm(state_bi, mlk_keccakf1600_round_constants);

  /* Deinterleave back to normal format */
  deinterleave_state(state, state_bi);

  mlk_zeroize(state_bi, sizeof(state_bi));
  return MLK_NATIVE_FUNC_SUCCESS;
}

#else /* MLK_FIPS202_ARMV81M_NEED_X1 && !MLK_CONFIG_MULTILEVEL_NO_SHARED */

MLK_EMPTY_CU(keccak_f1600_x1_armv7m)

#endif /* !(MLK_FIPS202_ARMV81M_NEED_X1 && !MLK_CONFIG_MULTILEVEL_NO_SHARED) \
        */

/* To facilitate single-compilation-unit (SCU) builds, undefine all macros.
 * Don't modify by hand -- this is auto-generated by scripts/autogen. */
/* Some macros are kept because they are also defined in a header. */
/* Keep: mlk_keccak_f1600_x1_native_impl (mve.h) */
